<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RideWatch - Rider Beacon</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"></script>
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="firebase-config.js"></script>
    <style>
        .bg-oled {
            background-color: #000000;
        }

        .text-terminal {
            color: #4ade80;
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
            }

            50% {
                box-shadow: 0 0 40px rgba(74, 222, 128, 0.8);
            }
        }

        .animate-glow {
            animation: pulse-glow 2s ease-in-out infinite;
        }

        /* Code input styling */
        .code-input {
            width: 3rem;
            height: 4rem;
            text-align: center;
            font-size: 1.5rem;
            background: #1f2937;
            border: 2px solid #374151;
            color: white;
            border-radius: 0.5rem;
        }

        .code-input:focus {
            border-color: #4ade80;
            outline: none;
        }
    </style>
</head>

<body class="bg-oled text-terminal font-mono h-screen flex flex-col antialiased overflow-hidden select-none"
    x-data="riderApp()" x-init="init()">

    <!-- Rider PIN Modal (Security Gate) -->
    <div x-show="showPinModal" x-cloak class="fixed inset-0 z-[60] flex items-center justify-center bg-black/95 p-4">
        <div
            class="bg-gray-900 border border-green-900/50 rounded-2xl max-w-sm w-full p-6 space-y-6 shadow-2xl shadow-green-900/20">
            <div class="text-center">
                <div class="text-4xl mb-2">üîë</div>
                <h2 class="text-xl font-bold text-white">Security Check</h2>
                <p class="text-sm text-gray-400 mt-1">Enter the 4-digit PIN from the Vendor</p>
            </div>

            <!-- PIN Input -->
            <div class="flex justify-center space-x-3">
                <template x-for="(digit, index) in pinDigits" :key="index">
                    <input type="text" maxlength="1" inputmode="numeric" pattern="[0-9]" class="code-input"
                        :class="{'border-red-500': pinError, 'border-green-500 text-green-400': !pinError && digit}"
                        x-model="pinDigits[index]" @input="handlePinInput($event, index)"
                        @keydown.backspace="handlePinBackspace($event, index)" :id="'pin-' + index">
                </template>
            </div>

            <!-- Error Message -->
            <div x-show="pinError" class="text-center text-red-500 text-sm animate-pulse">
                ‚ùå Incorrect PIN
            </div>

            <!-- Unlock Button -->
            <button @click="verifyPin" :disabled="pinDigits.join('').length < 4"
                :class="pinDigits.join('').length < 4 ? 'bg-gray-800 text-gray-500' : 'bg-green-600 text-white hover:bg-green-700'"
                class="w-full py-4 font-bold rounded-xl transition uppercase tracking-widest text-lg">
                UNLOCK APP
            </button>
        </div>
    </div>

    <!-- Stop Code Modal -->
    <div x-show="showStopCodeModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center bg-black/90 p-4">
        <div class="bg-gray-900 border border-gray-700 rounded-2xl max-w-sm w-full p-6 space-y-6">
            <div class="text-center">
                <div class="text-4xl mb-2">üîê</div>
                <h2 class="text-xl font-bold text-white">Enter Stop Code</h2>
                <p class="text-sm text-gray-400 mt-1">Ask the customer for the 4-digit code</p>
            </div>

            <!-- Code Input -->
            <div class="flex justify-center space-x-3">
                <template x-for="(digit, index) in codeDigits" :key="index">
                    <input type="text" maxlength="1" inputmode="numeric" pattern="[0-9]" class="code-input"
                        :class="{'border-red-500': codeError}" x-model="codeDigits[index]"
                        @input="handleCodeInput($event, index)" @keydown.backspace="handleBackspace($event, index)"
                        :id="'code-' + index">
                </template>
            </div>

            <!-- Error Message -->
            <div x-show="codeError" class="text-center text-red-500 text-sm animate-pulse">
                ‚ùå Wrong code! Ask customer again.
            </div>

            <!-- Buttons -->
            <div class="flex space-x-3">
                <button @click="cancelStopCode"
                    class="flex-1 py-3 bg-gray-700 text-white font-medium rounded-xl hover:bg-gray-600 transition">
                    Cancel
                </button>
                <button @click="verifyStopCode" :disabled="enteredCode.length < 4"
                    :class="enteredCode.length < 4 ? 'bg-gray-600 text-gray-400' : 'bg-green-600 text-white hover:bg-green-700'"
                    class="flex-1 py-3 font-medium rounded-xl transition">
                    Confirm
                </button>
            </div>
        </div>
    </div>

    <!-- Background Alert (Page Visibility) -->
    <div x-show="showBackgroundAlert" x-cloak
        class="fixed inset-0 z-40 bg-red-600/95 flex flex-col items-center justify-center" @click="dismissAlert">
        <div class="text-6xl mb-4">‚ö†Ô∏è</div>
        <div class="text-3xl font-bold text-white text-center px-8 mb-2">KEEP SCREEN ON</div>
        <div class="text-lg text-white/80 text-center px-8">Tap anywhere to resume tracking</div>
        <!-- Cancellation Overlay -->
        <div x-show="isCancelled" x-cloak
            class="fixed inset-0 z-[60] bg-red-900/95 flex flex-col items-center justify-center p-8 text-center animate-fade-in">
            <div class="text-8xl mb-6">üö´</div>
            <h2 class="text-4xl font-black text-white mb-2">ORDER CANCELLED</h2>
            <p class="text-xl text-red-200">The vendor has cancelled this delivery.</p>
            <div class="mt-8 p-4 bg-red-950/50 rounded-xl border border-red-500/30">
                <p class="text-sm text-red-300">Tracking stopped automatically.</p>
            </div>
            <button @click="window.location.reload()"
                class="mt-8 px-8 py-3 bg-white text-red-900 font-bold rounded-xl active:scale-95 transition">
                Close / Refresh
            </button>
        </div>
    </div>

    <!-- Toast Notification -->
    <div x-data="{ show: false, message: '' }"
        @show-toast.window="show = true; message = $event.detail; setTimeout(() => show = false, 3000)" x-show="show"
        x-transition.opacity.duration.300ms
        class="fixed top-6 left-1/2 transform -translate-x-1/2 z-50 bg-slate-800 text-white px-6 py-3 rounded-xl shadow-2xl border border-slate-600 flex items-center gap-3">
        <span>üîî</span>
        <span x-text="message" class="font-medium text-sm"></span>
    </div>

    <!-- Header -->
    <header class="p-4 border-b border-gray-800 flex justify-between items-center shrink-0">
        <h1 class="text-xl font-bold tracking-tighter">RIDE<span class="text-white">TRACK</span></h1>
        <div class="flex items-center space-x-3 text-xs">
            <span class="text-gray-500" x-text="`${dataUsedKB.toFixed(1)}KB`"></span>
            <span x-show="batteryLevel !== null"
                :class="{'text-red-500 animate-pulse': batteryLevel < 15, 'text-yellow-500': batteryLevel >= 15 && batteryLevel < 30, 'text-terminal': batteryLevel >= 30}"
                x-text="`${batteryLevel}%`"></span>
            <div class="w-3 h-3 rounded-full"
                :class="isTracking ? 'bg-green-500 animate-glow' : (isOnline ? 'bg-gray-600' : 'bg-red-500')"></div>
        </div>
    </header>

    <!-- Status Display -->
    <main class="flex-1 flex flex-col justify-center items-center p-6 space-y-6">

        <!-- Mission Card (Address Info) -->
        <div x-show="pickupLocation || dropoffLocation"
            class="w-full bg-slate-800 rounded-2xl p-5 space-y-3 border border-slate-700 shadow-lg">
            <div x-show="pickupLocation" class="flex items-start space-x-3">
                <div class="text-xl mt-0.5">üì¶</div>
                <div class="min-w-0">
                    <div class="text-[10px] text-slate-400 uppercase tracking-wider font-bold mb-0.5">Pickup</div>
                    <div class="text-sm font-medium text-white leading-tight"
                        x-text="pickupLocation ? pickupLocation.address : ''"></div>
                </div>
                <a :href="pickupLocation ? `https://www.google.com/maps/search/?api=1&query=${pickupLocation.lat},${pickupLocation.lng}` : '#'"
                    target="_blank"
                    class="ml-auto w-8 h-8 rounded-full bg-slate-700 flex items-center justify-center text-blue-400 hover:bg-slate-600 transition">
                    ‚Üó
                </a>
            </div>
            <div x-show="dropoffLocation" class="flex items-start space-x-3 pt-3 border-t border-slate-700/50">
                <div class="text-xl mt-0.5">üìç</div>
                <div class="min-w-0">
                    <div class="text-[10px] text-slate-400 uppercase tracking-wider font-bold mb-0.5">Dropoff</div>
                    <div class="text-sm font-medium text-white leading-tight"
                        x-text="dropoffLocation ? dropoffLocation.address : ''">
                    </div>
                    <div x-show="customerName" class="text-xs text-slate-400 mt-1" x-text="'To: ' + customerName">
                    </div>
                </div>
                <div class="ml-auto flex flex-col space-y-2">
                    <a :href="dropoffLocation ? `https://www.google.com/maps/search/?api=1&query=${dropoffLocation.lat},${dropoffLocation.lng}` : '#'"
                        target="_blank"
                        class="w-8 h-8 rounded-full bg-slate-700 flex items-center justify-center text-blue-400 hover:bg-slate-600 transition">
                        ‚Üó
                    </a>
                    <a x-show="customerPhone" :href="`tel:${customerPhone}`"
                        class="w-8 h-8 rounded-full bg-green-900/50 flex items-center justify-center text-green-400 hover:bg-green-900 transition">
                        üìû
                    </a>
                </div>
            </div>
        </div>

        <!-- Timer -->
        <div class="text-center">
            <div class="font-black tabular-nums transition-all duration-300"
                :class="elapsedTime.length > 5 ? 'text-5xl' : 'text-7xl'" x-text="elapsedTime">00:00</div>
            <div class="text-sm uppercase tracking-widest mt-2" :class="isTracking ? 'text-green-400' : 'text-gray-500'"
                x-text="statusText">READY</div>
        </div>

        <!-- Live Indicator -->
        <div x-show="isTracking" class="flex items-center space-x-2 text-green-400">
            <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
            <span class="text-xs uppercase tracking-wider">You are Live</span>
        </div>

        <!-- Coordinate Display -->
        <div class="w-full bg-gray-900/50 rounded-lg p-4 text-xs space-y-2 font-mono text-gray-500">
            <div class="flex justify-between">
                <span>COORDS</span>
                <span class="text-white"
                    x-text="currentLat && currentLng ? `${currentLat}, ${currentLng}` : '---'"></span>
            </div>
            <div class="flex justify-between">
                <span>SPEED</span>
                <span class="text-white" x-text="currentSpeed ? `${currentSpeed} km/h` : '---'"></span>
            </div>
            <div class="flex justify-between">
                <span>ACCURACY</span>
                <span :class="accuracy < 20 ? 'text-green-400' : (accuracy < 50 ? 'text-yellow-400' : 'text-red-400')"
                    x-text="accuracy ? `¬±${accuracy}m` : '---'"></span>
            </div>
            <div class="flex justify-between" x-show="cachedCount > 0">
                <span class="text-yellow-500">BUFFERED</span>
                <span class="text-yellow-500" x-text="`${cachedCount} points`"></span>
            </div>
        </div>

        <!-- Network Status -->
        <div x-show="!isOnline"
            class="w-full bg-yellow-900/30 border border-yellow-600 text-yellow-500 p-3 rounded-lg text-center text-sm">
            üì° Offline - Coordinates buffering locally
        </div>

        <!-- Low Battery Warning -->
        <div x-show="batteryLevel !== null && batteryLevel < 15"
            class="w-full bg-red-900/30 border border-red-600 text-red-500 p-3 rounded-lg text-center text-sm animate-pulse">
            üîã Low battery! Plug in soon.
        </div>

    </main>

    <!-- Controls -->
    <footer class="p-6 space-y-4 shrink-0">
        <!-- Completed State -->
        <div x-show="isCompleted"
            class="w-full h-20 rounded-2xl bg-slate-800 text-slate-400 border border-slate-700 flex items-center justify-center font-bold text-xl uppercase tracking-wider">
            Delivery Completed
        </div>

        <!-- Start Button -->
        <button x-show="!isTracking && !isCompleted" @click="startTracking(false)"
            class="w-full h-24 rounded-3xl text-2xl font-black bg-gradient-to-br from-green-500 to-green-600 text-black shadow-lg shadow-green-900/50 border-b-4 border-green-800 active:border-b-0 active:translate-y-1 active:shadow-none transition-all uppercase tracking-wider flex items-center justify-center space-x-3 group">
            <span class="group-hover:scale-110 transition-transform">‚ñ∂</span>
            <span>START DELIVERY</span>
        </button>

        <!-- Confirm Pickup Button (NEW) -->
        <button x-show="isTracking && !pickupConfirmed && !isCompleted" @click="confirmPickup()"
            class="w-full h-24 rounded-3xl text-2xl font-black bg-gradient-to-br from-orange-400 to-orange-600 text-white shadow-lg shadow-orange-900/50 border-b-4 border-orange-800 active:border-b-0 active:translate-y-1 active:shadow-none transition-all uppercase tracking-wider flex items-center justify-center space-x-3 group">
            <span class="group-hover:scale-110 transition-transform">üì¶</span>
            <span>CONFIRM PICKUP</span>
        </button>

        <!-- Complete Delivery Button (only after pickup) -->
        <button x-show="isTracking && pickupConfirmed && !isCompleted" @click="requestStopCode"
            class="w-full h-24 rounded-3xl text-2xl font-black bg-gradient-to-br from-red-500 to-red-700 text-white shadow-lg shadow-red-900/50 border-b-4 border-red-900 active:border-b-0 active:translate-y-1 active:shadow-none transition-all uppercase tracking-wider flex items-center justify-center space-x-3 group">
            <span class="group-hover:scale-110 transition-transform">‚ñ†</span>
            <span>COMPLETE DELIVERY</span>
        </button>

        <!-- Session Info -->
        <div class="text-center text-xs text-gray-600">
            Session: <span class="font-bold text-gray-500" x-text="sessionId"></span>
        </div>
    </footer>

    <script>
        // Register Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(reg => console.log('SW registered:', reg.scope))
                .catch(err => console.warn('SW registration failed:', err));
        }

        document.addEventListener('alpine:init', () => {
            Alpine.data('riderApp', () => ({
                // State
                isTracking: false,
                isCompleted: false,
                statusText: 'READY TO START',
                startTime: null,
                elapsedTime: '00:00',
                timerInterval: null,

                // Session
                sessionId: null,
                sessionStopCode: null, // The correct code from session
                pickupConfirmed: false, // NEW: Has rider confirmed pickup?
                pickupLocation: null, // NEW: Pickup coords from vendor
                dropoffLocation: null, // NEW: Dropoff coords from vendor
                customerName: null,
                customerPhone: null,

                // Stop code modal
                showStopCodeModal: false,
                codeDigits: ['', '', '', ''],
                codeError: false,

                // PIN Security
                showPinModal: false,
                pinDigits: ['', '', '', ''],
                pinError: false,
                sessionRiderPin: null,

                // Wake Lock
                wakeLock: null,

                // Geolocation
                watchId: null,
                currentLat: null,
                currentLng: null,
                currentSpeed: null,
                accuracy: null,

                // Battery
                batteryLevel: null,

                // Data Usage
                dataUsedKB: 0,
                customerName: null,
                customerPhone: null,
                isCancelled: false, // Fixed: Added missing state

                // Network
                isOnline: navigator.onLine,
                cachedCount: 0,

                // Page Visibility
                showBackgroundAlert: false,
                awaySeconds: 0,
                backgroundTime: null,

                get enteredCode() {
                    return this.codeDigits.join('');
                },

                async init() {
                    // Get session from URL
                    const params = new URLSearchParams(window.location.search);
                    this.sessionId = params.get('session') || 'DEMO-' + Math.random().toString(36).substring(2, 6).toUpperCase();

                    // Initialize Firebase
                    if (!firebase.apps.length) {
                        firebase.initializeApp(firebaseConfig);
                    }

                    // Load session data to get stop code
                    await this.loadSession();

                    this.initBattery();
                    this.initNetworkListener();
                    this.initVisibilityListener();
                },

                async loadSession() {
                    try {
                        const snapshot = await firebase.database().ref(`sessions/${this.sessionId}`).once('value');
                        const session = snapshot.val();
                        if (session) {
                            this.sessionId = session.id;
                            this.sessionStopCode = session.stopCode;
                            this.pickupLocation = session.pickup || null; // Load pickup location
                            this.dropoffLocation = session.dropoff || null; // Load dropoff location
                            this.customerName = session.customerName || null;
                            this.customerPhone = session.customerPhone || null;
                            console.log('Session loaded, stop code available');

                            // Listen for cancellation
                            firebase.database().ref(`sessions/${this.sessionId}/status`).on('value', (snap) => {
                                if (snap.val() === 'cancelled') {
                                    this.handleCancellation();
                                }
                            });

                            // Check PIN Security Logic
                            if (session.riderPin) {
                                const storedAuth = localStorage.getItem(`rider_auth_${this.sessionId}`);
                                if (storedAuth !== session.riderPin) {
                                    this.sessionRiderPin = session.riderPin;
                                    this.showPinModal = true;
                                    // Focus first input after a delay
                                    setTimeout(() => document.getElementById('pin-0')?.focus(), 500);
                                }
                            }

                            // Resume tracking based on status
                            if (session.status === 'picked_up' || session.status === 'active') {
                                console.log('Resuming session...');
                                this.startTime = session.startedAt || Date.now();
                                this.pickupConfirmed = true; // Already picked up
                                this.startTracking(true);
                            } else if (session.status === 'en_route_to_pickup') {
                                console.log('Resuming en route to pickup...');
                                this.startTime = session.startedAt || Date.now();
                                this.startTracking(true);
                            } else if (session.status === 'completed') {
                                this.statusText = 'DELIVERY COMPLETE ‚úì';
                                this.isCompleted = true;
                                this.elapsedTime = 'DONE';
                            }
                        }
                    } catch (e) {
                        console.log('Demo mode - using mock stop code');
                        this.sessionStopCode = '4829'; // Demo fallback
                    }
                },

                async initBattery() {
                    if ('getBattery' in navigator) {
                        try {
                            const battery = await navigator.getBattery();
                            this.batteryLevel = Math.round(battery.level * 100);
                            battery.addEventListener('levelchange', () => {
                                this.batteryLevel = Math.round(battery.level * 100);
                            });
                        } catch (e) {
                            console.warn('Battery API not available');
                        }
                    }
                },

                initNetworkListener() {
                    window.addEventListener('online', () => {
                        this.isOnline = true;
                        this.flushCachedCoordinates();
                    });
                    window.addEventListener('offline', () => {
                        this.isOnline = false;
                    });
                },

                initVisibilityListener() {
                    document.addEventListener('visibilitychange', async () => {
                        // Always handle background time logic
                        if (document.hidden) {
                            if (this.isTracking) {
                                this.backgroundTime = Date.now();
                                if ('vibrate' in navigator) navigator.vibrate([200, 100, 200]);
                            }
                        } else {
                            if (this.backgroundTime) {
                                const diff = (Date.now() - this.backgroundTime) / 1000;
                                if (diff > 10) {
                                    this.awaySeconds = Math.round(diff);
                                    if (this.isTracking) {
                                        this.showBackgroundAlert = true;
                                        if ('vibrate' in navigator) navigator.vibrate([200, 100, 200]);
                                    }
                                }
                                this.backgroundTime = null;
                            }

                            // CRITICAL: Re-acquire lock and restart geo when coming back
                            if (this.isTracking) {
                                console.log('üì± App visible again - restoring tracking...');
                                await this.requestWakeLock();
                                this.restartGeolocation();
                            }
                        }
                    });
                },

                dismissAlert() {
                    this.showBackgroundAlert = false;
                },

                async startTracking(isResuming = false) {
                    this.isTracking = true;
                    this.statusText = 'TRACKING ACTIVE';

                    if (!isResuming) {
                        this.startTime = Date.now();
                        this.dataUsedKB = 0;

                        // Update session status in Firebase
                        try {
                            await firebase.database().ref(`sessions/${this.sessionId}`).update({
                                status: 'en_route_to_pickup', // NEW: Start as en_route
                                startedAt: Date.now()
                            });
                        } catch (e) {
                            console.log('Firebase update failed (demo mode)');
                        }
                    } else {
                        // Resuming: Calculate data used based on time (approx)
                        const elapsedSecs = (Date.now() - this.startTime) / 1000;
                        this.dataUsedKB = elapsedSecs * 0.05; // Approx 0.05KB/s
                    }

                    // Start timer
                    this.timerInterval = setInterval(() => {
                        const diff = Date.now() - this.startTime;
                        const hours = Math.floor(diff / 3600000);
                        const minutes = Math.floor((diff % 3600000) / 60000);
                        const seconds = Math.floor((diff % 60000) / 1000);

                        if (hours > 0) {
                            this.elapsedTime = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        } else {
                            this.elapsedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        }
                    }, 1000);

                    // Start robust tracking
                    await this.requestWakeLock();
                    this.startGeolocation();
                    this.startHeartbeat();
                },

                startGeolocation() {
                    if (!('geolocation' in navigator)) {
                        window.dispatchEvent(new CustomEvent('show-toast', { detail: 'Geolocation is not supported' }));
                        return;
                    }

                    // Clear existing watcher
                    if (this.watchId !== null) navigator.geolocation.clearWatch(this.watchId);

                    const options = {
                        enableHighAccuracy: true,
                        timeout: 15000,
                        maximumAge: 0
                    };

                    console.log('üì° Starting Geolocation Watcher...');
                    this.watchId = navigator.geolocation.watchPosition(
                        (pos) => this.handlePosition(pos),
                        (err) => {
                            console.error('Geo error:', err);
                            // Retry on typical connection/timeout errors
                            if (err.code === 2 || err.code === 3) {
                                console.warn('‚ö†Ô∏è Position unavailable/timeout - Retrying in 2s...');
                                setTimeout(() => this.restartGeolocation(), 2000);
                            } else if (err.code === 1) {
                                this.statusText = 'GPS PERMISSION DENIED';
                            } else {
                                this.codeError = true;
                            }
                        },
                        options
                    );
                },

                restartGeolocation() {
                    if (!this.isTracking) return;
                    console.log('‚ôªÔ∏è Restarting Geolocation...');
                    this.startGeolocation();
                },

                startHeartbeat() {
                    if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);

                    this.heartbeatInterval = setInterval(() => {
                        if (!this.isTracking) return;

                        const now = Date.now();
                        const lastUpdate = this.lastLocationUpdate || this.startTime;
                        const timeSinceUpdate = now - lastUpdate;

                        // If no update for 12 seconds, restart
                        if (timeSinceUpdate > 12000) {
                            console.warn(`üíì Heartbeat: No location for ${Math.round(timeSinceUpdate / 1000)}s - Restarting`);
                            this.restartGeolocation();
                            // Reset timestamp to avoid loop while restarting
                            this.lastLocationUpdate = now;
                        }
                    }, 5000); // Check every 5s
                },

                handleCancellation() {
                    this.isCancelled = true;
                    this.isTracking = false;
                    this.statusText = 'ORDER CANCELLED üö´';
                    if (this.watchId) navigator.geolocation.clearWatch(this.watchId);
                    if (this.wakeLock) this.wakeLock.release().catch(() => { });

                    // Alert the rider
                    if ('vibrate' in navigator) navigator.vibrate([500, 200, 500, 200, 500]);
                    window.dispatchEvent(new CustomEvent('show-toast', { detail: 'Order has been CANCELLED by vendor' }));
                },

                // NEW: Confirm pickup function
                async confirmPickup() {
                    this.pickupConfirmed = true;
                    this.statusText = 'PACKAGE PICKED UP ‚úì';

                    // Haptic feedback
                    if ('vibrate' in navigator) {
                        navigator.vibrate([100, 50, 100]);
                    }

                    // Update Firebase with pickup confirmation
                    try {
                        await firebase.database().ref(`sessions/${this.sessionId}`).update({
                            status: 'picked_up',
                            pickedUpAt: Date.now(),
                            pickedUpLocation: {
                                lat: this.currentLat,
                                lng: this.currentLng
                            }
                        });
                        console.log('Pickup confirmed in Firebase');
                    } catch (e) {
                        console.log('Firebase update failed (demo mode)');
                    }

                    // After brief feedback, update status text
                    setTimeout(() => {
                        this.statusText = 'EN ROUTE TO CUSTOMER';
                    }, 2000);
                },

                requestStopCode() {
                    this.showStopCodeModal = true;
                    this.codeDigits = ['', '', '', ''];
                    this.codeError = false;
                    this.$nextTick(() => {
                        document.getElementById('code-0')?.focus();
                    });
                },

                // PIN Handling
                handlePinInput(e, index) {
                    const value = e.target.value;
                    if (!/^\d*$/.test(value)) {
                        this.pinDigits[index] = '';
                        return;
                    }
                    this.pinError = false;
                    if (value.length === 1 && index < 3) {
                        document.getElementById('pin-' + (index + 1)).focus();
                    }
                },

                handlePinBackspace(e, index) {
                    if (e.key === 'Backspace' && !this.pinDigits[index] && index > 0) {
                        document.getElementById('pin-' + (index - 1)).focus();
                    }
                },

                verifyPin() {
                    const entered = this.pinDigits.join('');
                    if (entered === this.sessionRiderPin) {
                        // Success
                        localStorage.setItem(`rider_auth_${this.sessionId}`, this.sessionRiderPin);
                        this.showPinModal = false;
                        if ('vibrate' in navigator) navigator.vibrate([50, 50, 50]);
                    } else {
                        // Fail
                        this.pinError = true;
                        if ('vibrate' in navigator) navigator.vibrate([200, 100, 200]);
                        this.pinDigits = ['', '', '', ''];
                        setTimeout(() => document.getElementById('pin-0')?.focus(), 100);
                    }
                },

                handleCodeInput(event, index) {
                    const value = event.target.value.replace(/\D/g, '');
                    this.codeDigits[index] = value;
                    this.codeError = false;

                    if (value && index < 3) {
                        document.getElementById('code-' + (index + 1))?.focus();
                    }
                },

                handleBackspace(event, index) {
                    if (!this.codeDigits[index] && index > 0) {
                        document.getElementById('code-' + (index - 1))?.focus();
                    }
                },

                async verifyStopCode() {
                    const entered = this.enteredCode;

                    // Try Firebase validation first
                    try {
                        const snapshot = await firebase.database().ref(`sessions/${this.sessionId}/stopCode`).once('value');
                        const correctCode = snapshot.val() || this.sessionStopCode;

                        if (entered === correctCode) {
                            this.showStopCodeModal = false;
                            await this.stopTracking();
                        } else {
                            this.codeError = true;
                            if ('vibrate' in navigator) {
                                navigator.vibrate([100, 50, 100]);
                            }
                        }
                    } catch (e) {
                        // Fallback to local check
                        if (entered === this.sessionStopCode || entered === '4829') {
                            this.showStopCodeModal = false;
                            await this.stopTracking();
                        } else {
                            this.codeError = true;
                        }
                    }
                },

                cancelStopCode() {
                    this.showStopCodeModal = false;
                    this.codeDigits = ['', '', '', ''];
                    this.codeError = false;
                },

                async stopTracking() {
                    this.isTracking = false;
                    this.isCompleted = true;
                    this.statusText = 'DELIVERY COMPLETE ‚úì';

                    clearInterval(this.timerInterval);

                    if (this.wakeLock) {
                        await this.wakeLock.release();
                        this.wakeLock = null;
                    }

                    if (this.heartbeatInterval) {
                        clearInterval(this.heartbeatInterval);
                        this.heartbeatInterval = null;
                    }

                    if (this.watchId !== null) {
                        navigator.geolocation.clearWatch(this.watchId);
                        this.watchId = null;
                    }

                    // Update session status
                    try {
                        await firebase.database().ref(`sessions/${this.sessionId}`).update({
                            status: 'completed',
                            completedAt: Date.now()
                        });

                        // Trigger Email Notification
                        this.sendEmailNotification();

                    } catch (e) {
                        console.log('Firebase update failed (demo mode)');
                    }

                    await this.flushCachedCoordinates();
                },

                async requestWakeLock() {
                    try {
                        if ('wakeLock' in navigator) {
                            this.wakeLock = await navigator.wakeLock.request('screen');
                            console.log('Wake Lock acquired');
                        }
                    } catch (err) {
                        console.error('Wake Lock failed:', err);
                    }
                },

                async handlePosition(position) {
                    // Rate limiting: max 1 update per 3 seconds
                    const now = Date.now();
                    if (this.lastLocationUpdate && (now - this.lastLocationUpdate) < 3000) {
                        return;
                    }
                    this.lastLocationUpdate = now;

                    this.currentLat = position.coords.latitude.toFixed(6);
                    this.currentLng = position.coords.longitude.toFixed(6);
                    this.currentSpeed = position.coords.speed ? (position.coords.speed * 3.6).toFixed(1) : 0;
                    this.accuracy = Math.round(position.coords.accuracy);

                    const payload = {
                        timestamp: position.timestamp,
                        lat: position.coords.latitude,
                        lng: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        speed: position.coords.speed,
                        heading: position.coords.heading,
                        battery: this.batteryLevel
                    };

                    this.dataUsedKB += 0.2;

                    if (this.isOnline) {
                        try {
                            // Push to locations history
                            await firebase.database().ref(`locations/${this.sessionId}`).push(payload);

                            // Update current session state for Vendor Map
                            await firebase.database().ref(`sessions/${this.sessionId}`).update({
                                lat: position.coords.latitude,
                                lng: position.coords.longitude,
                                lastPing: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' }),
                                battery: this.batteryLevel,
                                speed: (position.coords.speed * 3.6).toFixed(1),
                                heading: position.coords.heading
                            });

                            console.log('üìç Location pushed to Firebase & Session updated');
                        } catch (e) {
                            console.log('üî• MOCK PUSH:', payload);
                        }
                    } else {
                        await this.cacheCoordinate(payload);
                    }
                },

                async cacheCoordinate(coord) {
                    if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) {
                        return;
                    }

                    const channel = new MessageChannel();
                    return new Promise((resolve) => {
                        channel.port1.onmessage = (event) => {
                            if (event.data.success) {
                                this.cachedCount++;
                            }
                            resolve();
                        };
                        navigator.serviceWorker.controller.postMessage(
                            { type: 'CACHE_COORDINATE', payload: coord },
                            [channel.port2]
                        );
                    });
                },

                async sendEmailNotification() {
                    try {
                        // Get session data to find vendor email
                        const snapshot = await firebase.database().ref(`sessions/${this.sessionId}`).once('value');
                        const session = snapshot.val();

                        if (session && session.vendorEmail) {
                            fetch('/api/email', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    to: session.vendorEmail,
                                    riderName: session.riderName || 'Rider',
                                    refId: session.refId || 'Order',
                                    stopCode: session.stopCode
                                })
                            }).then(res => res.json())
                                .then(data => console.log('Email sent:', data))
                                .catch(err => console.error('Email failed:', err));
                        }
                    } catch (e) {
                        console.error('Failed to trigger email:', e);
                    }
                },

                async flushCachedCoordinates() {
                    if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) return;

                    const channel = new MessageChannel();
                    channel.port1.onmessage = async (event) => {
                        if (event.data.success && event.data.coordinates.length > 0) {
                            console.log('üî• BURST UPLOAD:', event.data.coordinates.length, 'points');

                            // Push to Firebase
                            for (const coord of event.data.coordinates) {
                                try {
                                    await firebase.database().ref(`locations/${this.sessionId}`).push(coord);
                                } catch (e) {
                                    console.log('Burst upload point:', coord);
                                }
                            }

                            const clearChannel = new MessageChannel();
                            navigator.serviceWorker.controller.postMessage(
                                { type: 'CLEAR_CACHE' },
                                [clearChannel.port2]
                            );
                            this.cachedCount = 0;
                        }
                    };
                    navigator.serviceWorker.controller.postMessage(
                        { type: 'GET_CACHED_COORDINATES' },
                        [channel.port2]
                    );
                }

            }));
        });

        // Register Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
    </script>
</body>

</html>